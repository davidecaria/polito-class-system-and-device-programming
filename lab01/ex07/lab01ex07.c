/*
A binary number of size n can be easily generated by a recursive function
like the one reported in file e05recursive.c

Transform the recursive program into a concurrent one, replacing the
recursive procedure with the generation of an appropriate number of
*processes*.
Each process must display one binary number.
Binary numbers can be displayed in any order.

For example, if n=3, the function must generate and print numbers:
000, 001, 010, 011, 100, 101, 110, 111
IN ANY ORDER.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>

void fromDecimalToInteger(int dec,int n);

int main(int argc, char *argv[]){

    if(argc != 2){
        printf("Error!\n");
        return -1;
    }

    int n;
    int *vet;
    int i;
    int bin;

    n = atoi (argv[1]);

   // double numberOfProcesses = pow((double)2,(double)n);
    
    

    vet = (int *)malloc(n * sizeof(int));
    if (vet == NULL) {
        printf("Allocatin Error.\n");
        exit(1);
    }

    __pid_t pid;


    for(i=0;i<8;i++){
        pid=fork();
        if(pid==0){
            break;
        }
    }

    if(pid==0){
        fromDecimalToInteger(i,n); 
    }


    return 0;
}

void fromDecimalToInteger(int dec, int n){

    int *outPut;
    outPut = (int *)malloc(n* sizeof(int));
    if(outPut == NULL){
        printf("Allocation Error \n");
        exit(EXIT_FAILURE);
    }

    for(int i=0;dec>0;i++){
        outPut[i]=dec%2;
        dec=dec/2;
        printf("%d",outPut[i]);
    }

    return;
}